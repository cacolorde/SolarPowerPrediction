#### Bibliotecas e Working Directory ####
library(ggplot2)
library(plotly)
library(DataExplorer)
library(tidymodels)
library(readr)
library(corrplot)
library(GGally)
library(neuralnet)
library(e1071)
library(reshape2)
library(quantmod)
library(lubridate)
library(caret)
library(doParallel)
cl <- makePSOCKcluster(5)
registerDoParallel(cl)

#### Leitura de dados ####
plant_1_gen <- read.csv("Plant_1_Generation_Data.csv", header = TRUE)
plant_1_weather <- read.csv("Plant_1_Weather_Sensor_Data.csv", header = TRUE)

#### O que cada coluna significa ####
date_time_col <- "Date and time for each observation. Observations recorded at 15 minute intervals"
source_key <- "Source key in this file stands for the inverter id"
dc_power <- "Amount of DC power generated by the inverter (source_key) in this 15 minute interval. Units - kW"
ac_power <- "Amount of AC power generated by the inverter (source_key) in this 15 minute interval. Units - kW"
daily_yield <- "Daily yield is a cumulative sum of power generated on that day, till that point in time"
total_yield <- "This is the total yield for the inverter till that point in time"


hour_2_min <- function(x){
  hour_obj <- hms::as.hms(strptime(x, format="%H:%M"))
  new_str <- strsplit(as.character(hour_obj), ":")
  hour <- as.integer(new_str[[1]][1])
  min <- as.integer(new_str[[1]][2])
  minutes <- (hour*60) + min
  return(minutes)
}

#### Fun??o para prepara??o dos dados ####
prepare_data <- function(data) {
  data <- data %>%
    separate(
      DATE_TIME, c("DATE", "TIME"), " ") %>%
    mutate(
      DATE_TIME = as.POSIXct(strptime(paste(DATE, TIME, sep = " "), format="%Y-%m-%d %H:%M:%S")),
      DATE = as.POSIXct(strptime(DATE, '%Y-%m-%d')),
      TIME = hms::as.hms(strptime(TIME, format="%H:%M")),
    ) %>%
    filter(
      DATE != "2020-05-20" &
        DATE != "2020-05-21" & 
        DATE != "2020-05-26" &
        DATE != "2020-05-29" &
        DATE != "2020-06-07" &
        DATE != "2020-06-14"
    )    
  
  return(data)
}

#### Preparando dados - Planta 1 ####
'%notin%' <- Negate('%in%')
plant_1_gen <- plant_1_gen %>%
  separate(
    DATE_TIME, c("DATE", "TIME"), " ") %>%
  mutate(
    HORARIO = TIME,
  ) %>%
  separate(
    HORARIO, c("HOUR", "MINUTES"), ":"
  ) %>%
  mutate(
    DATE_TIME = as.POSIXct(strptime(paste(DATE, TIME, sep = " "), format="%d-%m-%Y %H:%M")),
    DATE = as.POSIXct(strptime(DATE, '%d-%m-%Y')),
    TIME = hms::as.hms(strptime(TIME, format="%H:%M")),
    MINUTES_SINCE = 60*as.double(HOUR) + as.double(MINUTES)
  ) %>%
  # Removendo o inversor que apontou problemas durane o per?odo em an?lise
  # Removendo datas com erros de medi??o
  filter(
    SOURCE_KEY %notin% c("1BY6WEcLGh8j5v7", "sjndEbLyjtCKgGv", "z9Y9gH1T5YWrNuG",
                         "zVJPv84UY57bAof", "zBIq5rxdHJRwDNY", "wCURE6d3bPkepu2",
                         "McdE0feGgRqW7Ca", "bvBOhCH3iADSZry"),
    DATE != "2020-05-20" &
      DATE != "2020-05-21" & 
      DATE != "2020-05-26" &
      DATE != "2020-05-29" &
      DATE != "2020-06-07" &
      DATE != "2020-06-14"
  )


plant_1_weather <- prepare_data(plant_1_weather)


#### Fun??es para visualiza??o dos dados ####
plot_plant_data_pday <- function (data){
  data %>%
    ggplot(aes(x = TIME, y = AC_POWER, col = SOURCE_KEY)) +
    geom_point() +
    facet_wrap(vars(DATE))+
    scale_x_datetime(date_labels = "%H:%M") +
    labs(
      title = "Pot?ncia Gerada por cada inversor por dia - Planta",
      y = "Pot?ncia CA em kW",
      x = "Hor?rio do dia",
      col = "C?digo de cada Inversor"
    )
  
}

plot_plant_data_pinversor <- function (data){
  data %>%
    ggplot(aes(x = TIME, y = AC_POWER, col = DATE)) +
    geom_point() +
    facet_wrap(vars(SOURCE_KEY))+
    scale_x_datetime(date_labels = "%H:%M") +
    labs(
      title = "Pot?ncia Gerada por cada inversor por dia - Planta",
      y = "Pot?ncia CA em kW",
      x = "Hor?rio do dia",
      col = "Data"
    )
  
}

plot_weather_data <- function(data, string) {
  data %>%
    ggplot(aes(x = TIME, y = IRRADIATION, col = AMBIENT_TEMPERATURE)) +
    geom_point() + 
    scale_x_datetime(date_labels = "%H:%M") +
    facet_wrap(vars(DATE)) +
    labs(
      title = paste("Irradia??o Solar e Temperatura do Ambiente - Planta", string, sep=" "),
      y = "Quantidade de Irradia??o Solar",
      x = "Hor?rio do dia",
      col = "Temperatura Ambiente"
    ) +
    scale_color_gradientn(colors = c("#000066", "#FF0000", "#FFFF00"))
}

plot_daily_yield <- function(data, string){
  data %>%
    ggplot(aes(x = TIME, y = DAILY_YIELD, col = SOURCE_KEY)) +
    geom_point() +
    facet_wrap(vars(DATE))+
    scale_x_datetime(date_labels = "%H:%M") +
    labs(
      title = paste("Pot?ncia Total Gerada por cada inversor - Planta", string, sep=" "),
      y = "Pot?ncia CA em kW",
      x = "Hor?rio do dia",
      col = "Data"
    )
}

plot_correl <- function(data_gen = NULL, data_weather= NULL, all_data = NULL){
  if (is.null(all_data)){
    corr_M <- merge(data_weather, data_gen, by="DATE_TIME")
  }else if (is.null(data_gen) && is.null(data_weather)){
    corr_M <- all_data
  }
  corr_M <- corr_M %>%
    subset(
      select = c(
        AMBIENT_TEMPERATURE,
        MODULE_TEMPERATURE,
        AC_POWER,
        IRRADIATION,
        MINUTES_SINCE
      )
    )
  correlation <- cor(corr_M)
  colnames(correlation) <- c("Temperatura do Ambiente", "Temperatura do M?dulo", "Pot?ncia CA", "Irradia??o", "Hor?rio")
  rownames(correlation) <- c("Temperatura do Ambiente", "Temperatura do M?dulo", "Pot?ncia CA", "Irradia??o", "Hor?rio")
  corrplot(
    correlation, 
    method="color",
    addCoef.col = "orange",
    type= "upper",
    diag=FALSE,
  )
}

plot_pairs <- function(data_gen, data_weather){
  pair_M <- merge(data_weather, data_gen, by="DATE_TIME")
  pair_M <- pair_M %>%
    subset(
      select = c(
        AMBIENT_TEMPERATURE,
        MODULE_TEMPERATURE,
        AC_POWER,
        IRRADIATION,
        MINUTES_SINCE
      )
    )
  pairs(pair_M)
}

scale_my_data <- function(x){
  (x - min(x)) / (max(x) - min(x))
}

unscale_my_data <- function(y) {
  ((y*(max(plant_1_gen$AC_POWER) - 0))-0)
}

#### Visualiza??o  ####
#plot_plant_data_pday(plant_1_gen)
#plot_plant_data_pinversor(plant_1_gen)
#plot_weather_data(plant_1_weather, 1)
#plot_daily_yield(plant_1_gen, "1")
#plot_correl(plant_1_gen, plant_1_weather)
#plot_pairs(plant_1_gen, plant_1_weather)


#### Preparando dos dados para o modelo ####
prepare_learning_data <- function(data_gen, data_weather){
  # Seleciona as colunas importantes
  feature_output_data <- data_weather %>%
    merge(
      data_gen,
      by = "DATE_TIME"
    ) %>%
    # Features:  AMBIENT_TEMPERATURE, MODULE_TEMPERATURE,IRRADIATION
    # Outputs: AC_POWER
    subset(
      select = c( AMBIENT_TEMPERATURE, MODULE_TEMPERATURE,IRRADIATION, MINUTES_SINCE, AC_POWER)
    ) %>%
    # Normaliza o vetor entre [0, 1]
    mutate_all(scale_my_data) %>%
    mutate(
      MINUTES_SINCE = (sin(pi*MINUTES_SINCE))^5,
    )
  
  # Embaralha o vetor
  feature_output_data <- feature_output_data[sample(1:nrow(feature_output_data),length(1:nrow(feature_output_data))),1:ncol(feature_output_data)]
  feature_output_data <- feature_output_data %>% mutate(ROW = row_number())
  
  return(feature_output_data)
}

all_data <- prepare_learning_data(plant_1_gen, plant_1_weather)
#plot_correl(all_data = all_data)
set.seed(3108)

train_data <- sample_frac(tbl = all_data, replace = FALSE, size = 0.8)
test_data  <- anti_join(all_data, train_data, by="ROW")

train_data <- drop_columns(train_data, "ROW")
test_data <- drop_columns(test_data, "ROW")

ggpairs(drop_columns(all_data, "ROW"))


#### Rede Neural sem camadas escondidas ####
NN1 <- neuralnet(
  AC_POWER ~ AMBIENT_TEMPERATURE + MODULE_TEMPERATURE + IRRADIATION + MINUTES_SINCE,
  data = train_data,
  lifesign = "full",
  hidden = 0,
  rep=1,
  threshold = 0.01,
  likelihood = TRUE,
  err.fct = "sse",
)

#### NN1 -Visualizando a Rede ####
plot(NN1, rep = 'best')

#### NN1 - Testando a Rede ####
NN1_prediction <- predict(NN1, test_data[, 1:4], interval = "confidence")

#### NN1 - Erro da Rede ####  
NN1_MSE <- round(sum(abs(NN1_prediction - test_data$AC_POWER))/nrow(NN1_prediction), 4)
NN1_RMSE <- rmse(
  data.frame(
    NN1_prediction = NN1_prediction,
    TARGET=test_data$AC_POWER
  ), 
  TARGET, 
  NN1_prediction
)
perc_in_RMSE_band_NN1 <- round(
  sum(
    abs(
      test_data$AC_POWER - NN1_prediction
    ) < NN1_RMSE$.estimate
  )/nrow(test_data),
  4)

#paste("NN1 - MSE: ", round(NN1_MSE, 2), sep= "")
paste("RMSE: ", round(NN1_RMSE$.estimate*100, 2), "%",sep= "")

#### NN1 - Visualiza??o da Efici?ncia da Rede ####

test_data%>%
  mutate(
    PREDICTION = NN1_prediction,
  ) %>%
  subset(
    select=c(PREDICTION, AC_POWER)
  ) %>%
  mutate_all(unscale_my_data) %>%
  ggplot(aes(x = AC_POWER, y = PREDICTION)) +
  geom_point()+
  scale_x_continuous(name="Resultado Esperado (kW)")+
  scale_y_continuous(name="Previs?o (kW)")+
  geom_abline(slope=1, intercept=0, color="red")+
  geom_ribbon(
    aes(
      xmin = PREDICTION-(1405.3*NN1_RMSE$.estimate),
      xmax = PREDICTION+(1405.3*NN1_RMSE$.estimate),
      fill="red",
    ),
    alpha = 0.5,
  )+
  scale_fill_discrete(
    name = paste0("Precis?o de ", round(100*NN1_RMSE$.estimate, 2), "%"),
    labels = c(paste0("+/- ", round(1405.3*NN1_RMSE$.estimate, 2), " kW", sep=" "))
  )+
  annotate("text", x=1170, y=150, colour="red", label=paste0(100*perc_in_RMSE_band_NN1, "% das previs?es dentro da faixa vermelha"))

#### Rede Neural com neur?nios escondidos ####
set.seed(166)
NN2 <- neuralnet(
  AC_POWER ~ AMBIENT_TEMPERATURE + MODULE_TEMPERATURE + IRRADIATION + MINUTES_SINCE,
  data = train_data,
  lifesign = "full",
  rep=1,
  hidden = 4,
  likelihood = TRUE,
  threshold = 0.1
)

#### NN2 -Visualizando a Rede ####
plot(NN2, rep = 'best')

#### NN2 -Testando a Rede ####
NN2_prediction <- predict(NN2, test_data[, 1:4])

#### NN2 - Erro da Rede ####
NN2_MSE <- round(sum(abs(NN2_prediction - test_data$AC_POWER))/nrow(NN2_prediction), 4)
NN2_RMSE <- rmse(
  data.frame(
    NN2_prediction = NN2_prediction,
    TARGET=test_data$AC_POWER
  ), 
  TARGET, 
  NN2_prediction
)
perc_in_RMSE_band_NN2 <- round(
  sum(
    abs(
      test_data$AC_POWER - NN2_prediction
    ) < NN2_RMSE$.estimate
  )/nrow(test_data),
  4)

#paste("NN2 - MSE: ", NN2_MSE*100, "%",sep= "")
paste("RMSE: ", round(NN2_RMSE$.estimate*100, 2), "%",sep= "")

#### NN2 - Visualiza??o da Efici?ncia da Rede ####
test_data %>%
  mutate(
    PREDICTION = NN2_prediction
  ) %>%
  subset(
    select=c(PREDICTION, AC_POWER)
  ) %>%
  mutate_all(unscale_my_data) %>%
  ggplot(aes(y = PREDICTION, x = AC_POWER)) +
  geom_point()+
  scale_x_continuous(name="Pot?ncia Gerada em kW")+
  scale_y_continuous(name="Pot?ncia Prevista em kW")+
  geom_abline(slope=1, intercept=0, color="red")+
  geom_ribbon(
    aes(
      xmin = PREDICTION-(1405.3*NN2_RMSE$.estimate),
      xmax = PREDICTION+(1405.3*NN2_RMSE$.estimate),
      fill="red",
    ),
    alpha = 0.5,
  )+
  scale_fill_discrete(
    name = paste0("Precis?o de ", round(100*NN2_RMSE$.estimate, 2), "%"),
    labels = c(paste0("+/- ", round(1405.3*NN2_RMSE$.estimate, 2), " kW", sep=" "))
  )+
  annotate("text", x=1170, y=150, colour="red", label=paste0(100*perc_in_RMSE_band_NN2, "% das previs?es dentro da faixa vermelha"))

#### Support Vector Machine ####
#### Encontrando os melhores par?metros para o modelo ####
tune <- tune(
  method = svm,
  AC_POWER ~ AMBIENT_TEMPERATURE + MODULE_TEMPERATURE + IRRADIATION + MINUTES_SINCE,
  data = train_data[1000:2001,],
  kernel = "linear",
  ranges = list(cost = c(0.1, 1, 10), epsilon = c(1, 0.1, 0.01))
)
svm_cost <- tune[1]$best.parameters$cost
svm_epsilon <- tune[1]$best.parameters$epsilon

svm_model <- svm(
  AC_POWER ~ AMBIENT_TEMPERATURE + MODULE_TEMPERATURE + IRRADIATION + MINUTES_SINCE,
  data = train_data,
  kernel = "linear",
  cost = svm_cost,
  epsilon = svm_epsilon,
)

#### SVM - Testando o Modelo ####
svm_prediction <- predict(svm_model, test_data[,1:4])
svm_prediction <- data.frame(svm_prediction = unname(svm_prediction))
svm_prediction <- svm_prediction %>%
  mutate(
    TARGET = test_data$AC_POWER
  )

#### SVM - Erro do Modelo ####
svm_RMSE <- rmse(svm_prediction, TARGET, svm_prediction)
svm_MSE <- round(sum(abs(svm_prediction - test_data$AC_POWER))/nrow(test_data), 4)
perc_in_RMSE_band_svm <- round(
  sum(
    abs(
      test_data$AC_POWER - svm_prediction$svm_prediction
    ) < svm_RMSE$.estimate
  )/nrow(test_data),
  4)


#paste("MSE: ", svm_MSE*100, "%",sep= "")
paste("RMSE: ", round(svm_RMSE$.estimate*100, 2), "%",sep= "")


#### SVM - Visualizando a Efici?ncia da Modelo ####
test_data %>%
  mutate(
    PREDICTION = svm_prediction$svm_prediction
  ) %>%
  subset(
    select=c(PREDICTION, AC_POWER)
  ) %>%
  mutate_all(unscale_my_data) %>%
  ggplot(aes(y = PREDICTION, x = AC_POWER)) +
  geom_point()+
  scale_x_continuous(name="Pot?ncia Gerada em kW")+
  scale_y_continuous(name="Pot?ncia Prevista em kW")+
  geom_abline(slope=1, intercept=0, color="red")+
  geom_ribbon(
    aes(
      xmin = PREDICTION-(1405.3*svm_RMSE$.estimate),
      xmax = PREDICTION+(1405.3*svm_RMSE$.estimate),
      fill="red",
    ),
    alpha = 0.5,
  )+
  scale_fill_discrete(
    name = paste0("Precis?o de ", round(100*svm_RMSE$.estimate, 2), "%"),
    labels = c(paste0("+/- ", round(1405.3*svm_RMSE$.estimate, 2), " kW", sep=" "))
  )+
  annotate("text", x=1170, y=150, colour="red", label=paste0(100*perc_in_RMSE_band_svm, "% das previs?es dentro da faixa vermelha"))

#### PLOTANDO TODAS AS PREVIS?ES ####

ggplotly(
  test_data %>%
    mutate(
      PREDICTION_NN1 = NN1_prediction,
      PREDICTION_NN2 = NN2_prediction,
      PREDICTION_SVM =  svm_prediction$svm_prediction,
    ) %>%
    subset(
      select=c(AC_POWER, PREDICTION_SVM, PREDICTION_NN1, PREDICTION_NN2)
    ) %>%
    mutate_all(unscale_my_data) %>%
    melt(id.vars="AC_POWER") %>%
    ggplot(aes(x = AC_POWER, y = value, col=variable)) +
    geom_point(size=1)+
    scale_x_continuous(name="Pot?ncia Gerada em kW")+
    scale_y_continuous(name="Pot?ncia Prevista em kW")+
    geom_abline(slope=1, intercept=0, color="red")+
    annotate("text", x=1170, y=150, colour="black", label="Modelo |  MSE  | RMSE")+
    annotate("text", x=1200, y=100, colour="#f8766d", label=paste("SVM |", svm_MSE*100, "%", " | ", round(svm_RMSE$.estimate*100, 2), "%"))+
    annotate("text", x=1200, y=50, colour="#00ba38", label=paste("NN1 |", NN1_MSE*100, "%", " | ", round(NN1_RMSE$.estimate*100, 2), "%"))+
    annotate("text", x=1190, y=0, colour="#619bff", label=paste("NN2 |", NN2_MSE*100, "%", " | ", round(NN2_RMSE$.estimate*100, 2), "%"))+
    scale_color_discrete(name="Modelos", labels=c( "M?quina de Vetor Suporte", "Perceptron de Rosemblatt", "Perceptron de Multiplas Camadas")),
  dynamicTicks = TRUE
) %>%
  config(scrollZoom = TRUE)
#learning_curve_dat(train_data, "AC_POWER", test_prop = 0.85, verbose = TRUE)

# teste de hip?tese para verificar equival?ncia dos modelos
# https://www.google.com/url?sa=j&url=http%3A%2F%2Fwww.portalaction.com.br%2Finferencia%2F57-teste-para-comparacao-de-duas-medias-teste-t&uct=1611553425&usg=2V4rsYestMQBw9rj-WnwZrOdPxI.&source=meet
t.test(NN1_prediction, NN2_prediction, mu = mean(test_data$AC_POWER))
t.test(NN1_prediction, svm_prediction$svm_prediction, mu=mean(test_data$AC_POWER))
t.test(NN2_prediction, svm_prediction$svm_prediction, mu=mean(test_data$AC_POWER))


saveRDS(NN1, "rosemblatt_perceptron.rds")
saveRDS(NN2, "hidden_layers.rds")
saveRDS(svm_model, "support_vector.rds")

stopCluster(cl)
